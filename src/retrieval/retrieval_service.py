import logging
from wireup import service
from src.core.services.embedder import IEmbedder
from src.retrieval.query_invoice_repository import IQueryInvoiceRepository
from src.retrieval.query_router import QueryRouter
from src.retrieval.answer_generator import AnswerGenerator
from src.retrieval.tools import SearchLineItemsTool, SearchInvoicesTool
from src.core.models import (
    InvoiceProjection,
    LineItemProjection,
)

logger = logging.Logger(__name__)


@service
class RetrievalService:
    """
    ⚙️ Retrieval Service (Orchestrator)

    Main service that orchestrates the retrieval workflow:
    1. Calls QueryRouter to analyze intent and get search filters
    2. Calls Repository to build query pipelines from filters and execute search
    3. Decides whether to generate an answer or return structured data
    """

    def __init__(
        self,
        query_router: QueryRouter,
        answer_generator: AnswerGenerator,
        embedder: IEmbedder,
        repository: IQueryInvoiceRepository,
    ) -> None:
        self._query_router: QueryRouter = query_router
        self._answer_generator: AnswerGenerator = answer_generator
        self._embedder: IEmbedder = embedder
        self._repository: IQueryInvoiceRepository = repository

    async def retrieve(
        self,
        user_query: str,
        is_llm_generated: bool = False,
    ) -> str | list[LineItemProjection] | list[InvoiceProjection]:
        """
        Args:
            user_query: The natural language query from the user
            is_llm_generated: Whether the query was generated by an LLM

        Returns:
            Either a generated answer string or structured data
        """
        logger.info(f"Received query: {user_query}")

        # Step 1: Call QueryRouter to analyze intent and select tool
        criteria: str | SearchLineItemsTool | SearchInvoicesTool = (
            self._query_router.route(user_query)
        )
        logger.info(f"Selected tool: {type(criteria)}.")

        # Step 2: Handle the routing result (either a tool or a text response)
        if isinstance(criteria, str):
            # If the router returned a text response instead of a tool, return it directly
            return criteria

        logger.info(f"Tool data:\n{criteria.model_dump_json(indent=4)}")
        results: list[LineItemProjection] | list[InvoiceProjection]
        context: str
        # Step 3: Process the selected tool
        if isinstance(criteria, SearchLineItemsTool):
            embedding: list[float] | None = None
            if criteria.query_text:
                embedding = self._embedder.embed_text(text=criteria.query_text)

            results = await self._repository.search_line_items(criteria, embedding)
            context = self._format_items_context(results)
        elif isinstance(criteria, SearchInvoicesTool):
            results = await self._repository.search_invoices(criteria)
            context = self._format_invoices_context(results)
        else:
            raise ValueError(f"Unknown tool type returned by router: {type(criteria)}")

        logger.info(f"Context:\n{context}")
        if is_llm_generated:
            if not results:
                return "I couldn't find any documents matching those specific criteria."
            # Generate a grounded answer using the AnswerGenerator
            answer: str = self._answer_generator.generate_answer(user_query, context)
            return answer
        else:
            # Format and return structured data (JSON Response)
            return results

    def _format_items_context(self, items: list[LineItemProjection]) -> str:
        context_str = "Found Line Items:\n"
        for item in items:
            context_str += (
                f"- Item: {item.description} | "
                + (f"Cost: {item.total_amount} | " if item.total_amount else "")
                + (f"Date: {item.delivery_date} | " if item.delivery_date else "")
                + (f"Inv#: {item.invoice_number} | " if item.invoice_number else "")
                + f"[Page: {item.page_number}]\n"
            )
        return context_str

    def _format_invoices_context(self, invoices: list[InvoiceProjection]) -> str:
        # Should be implemented
        return "\n".join([invoice.model_dump_json() for invoice in invoices])
