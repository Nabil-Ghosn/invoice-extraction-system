from typing import Any

from wireup import service
from src.core.services.embedder import IEmbedder
from src.retrieval.query_router import QueryRouter
from src.retrieval.query_translator import QueryTranslator
from src.retrieval.answer_generator import AnswerGenerator
from src.retrieval.tools import SearchLineItemsTool, SearchInvoicesTool
from src.core.models import (
    InvoiceProjection,
    LineItemModel,
    InvoiceModel,
    LineItemProjection,
)


@service
class RetrievalService:
    """
    ⚙️ Retrieval Service (Orchestrator)

    Main service that orchestrates the retrieval workflow:
    1. Calls QueryRouter to analyze intent
    2. Calls QueryTranslator to map args to filters
    3. Calls Repository to execute search
    4. Decides whether to generate an answer or return structured data
    """

    def __init__(
        self,
        query_router: QueryRouter,
        query_translator: QueryTranslator,
        answer_generator: AnswerGenerator,
        embedder: IEmbedder,
    ) -> None:
        self._query_router: QueryRouter = query_router
        self._query_translator: QueryTranslator = query_translator
        self._answer_generator: AnswerGenerator = answer_generator
        self._embedder: IEmbedder = embedder

    async def retrieve(
        self,
        user_query: str,
        is_llm_generated: bool = False,
    ) -> str | list[LineItemProjection] | list[InvoiceProjection]:
        """
        Args:
            user_query: The natural language query from the user
            is_llm_generated: Whether the query was generated by an LLM

        Returns:
            Either a generated answer string or structured data
        """
        # Step 1: Call QueryRouter to analyze intent and select tool
        criteria: str | SearchLineItemsTool | SearchInvoicesTool = (
            self._query_router.route(user_query)
        )

        # Step 2: Handle the routing result (either a tool or a text response)
        if isinstance(criteria, str):
            # If the router returned a text response instead of a tool, return it directly
            return criteria

        results: list[LineItemProjection] | list[InvoiceProjection]
        context: str
        # Step 3: Process the selected tool
        if isinstance(criteria, SearchLineItemsTool):
            embedding: list[float] | None = None
            if criteria.query_text:
                embedding = self._embedder.embed_text(text=criteria.query_text)

            # Generate the MongoDB pipeline using the QueryTranslator
            pipeline = await self._query_translator.generate_line_item_pipeline(
                criteria, embedding
            )

            # Execute the pipeline using beanie
            results = await LineItemModel.aggregate(
                pipeline, projection_model=LineItemProjection
            ).to_list(length=None)
            context = self._format_items_context(results)
        elif isinstance(criteria, SearchInvoicesTool):
            # Generate the MongoDB pipeline using the QueryTranslator
            pipeline: list[dict[str, Any]] = (
                self._query_translator.generate_invoice_pipeline(criteria)
            )

            # Execute the pipeline using beanie
            results = await InvoiceModel.aggregate(
                pipeline, projection_model=InvoiceProjection
            ).to_list(length=None)
            context = self._format_invoices_context(results)
        else:
            raise ValueError(f"Unknown tool type returned by router: {type(criteria)}")
        if is_llm_generated:
            # Generate a grounded answer using the AnswerGenerator
            answer: str = self._answer_generator.generate_answer(user_query, context)
            return answer
        else:
            # Format and return structured data (JSON Response)
            return results

    def _format_items_context(self, items: list[LineItemProjection]) -> str:
        context_str = "Found Line Items:\n"
        for item in items:
            context_str += (
                f"- Item: {item.description} | "
                + (f"Cost: {item.total_amount} | " if item.total_amount else "")
                + (f"Date: {item.delivery_date} | " if item.delivery_date else "")
                + f"[Inv: {str(item.invoice_id)}, Page: {item.page_number}]\n"
            )
        return context_str

    def _format_invoices_context(self, invoices: list[InvoiceProjection]) -> str:
        # Should be implemented
        return "\n".join([invoice.model_dump_json() for invoice in invoices])
